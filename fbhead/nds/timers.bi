''
''
'' timers -- header translated with help of SWIG FB wrapper
''
'' NOTICE: This file is part of the FreeBASIC Compiler package and can't
''         be included in other distributions without authorization.
''
''
#ifndef __timers_bi__
#define __timers_bi__

#define TIMER_CR(n)   cast_vu16_ptr(&h04000102+((n) shl 2))
#define TIMER0_CR     cast_vu16_ptr(&h04000102)
#define TIMER1_CR     cast_vu16_ptr(&h04000106)
#define TIMER2_CR     cast_vu16_ptr(&h0400010A)
#define TIMER3_CR     cast_vu16_ptr(&h0400010E)

'TIMER_DATA(n) when set will latch that value into the counter.  Everytime the
'counter rolls over %TIMER_DATA(0) will return to the latched value.  This allows
'you to control the frequency of the timer using the following formula:
'TIMER_DATA(x) = -(BUS_CLOCK/(freq * divider));

#define TIMER_DATA(n) cast_vu16_ptr(&h04000100+((n) shl 2))
#define TIMER0_DATA   cast_vu16_ptr(&h04000100)
#define TIMER1_DATA   cast_vu16_ptr(&h04000104)
#define TIMER2_DATA   cast_vu16_ptr(&h04000108)
#define TIMER3_DATA   cast_vu16_ptr(&h0400010C)

#define BUS_CLOCK cuint(33513982)
#define TIMER_ENABLE (1 shl 7)
#define TIMER_IRQ_REQ (1 shl 6)
#define TIMER_CASCADE (1 shl 2)

enum ClockDivider
	ClockDivider_1    = 0 'Causes the timer to count at 33.514 Mhz.
	ClockDivider_64   = 1 'Causes the timer to count at 33.514/64 Mhz.
	ClockDivider_256  = 2 'Causes the timer to count at 33.514/256 Mhz.
	ClockDivider_1024 = 3 'Causes the timer to count at 33.514/1024 Mhz.
end enum

#define TIMER_DIV_1 (0)
#define TIMER_DIV_64 (1)
#define TIMER_DIV_256 (2)
#define TIMER_DIV_1024 (3)

#define TIMER_FREQ(n)    (-BUS_CLOCK\(n))
#define TIMER_FREQ_64(n)  (-(BUS_CLOCK shr 6)\(n))
#define TIMER_FREQ_256(n) (-(BUS_CLOCK shr 8)\(n))
#define TIMER_FREQ_1024(n) (-(BUS_CLOCK shr 10)\(n))

'Callback is tied directly to interrupt table and called directly, resulting in less latency than the attached timer.
'timer 	The hardware timer to use (0 - 3).
'divider 	The timer channel clock divider (clock will tick at 33.513982 MHz / divider)
'ticks	The number of ticks which must elapse before the timer overflows
'callback The callback to be called when the timer expires (if null, no IRQ will be generated by the timer)

declare sub timerStart cdecl alias "timerStart" (byval timer as integer, byval divider as ClockDivider, byval ticks as short, byval callback as VoidFn)
declare function timerElapsed cdecl alias "timerElapsed" (byval timer as integer) as u16
declare function timerPause cdecl alias "timerPause" (byval timer as integer) as u16
declare function timerStop cdecl alias "timerStop" (byval timer as integer) as u16
declare sub cpuStartTiming cdecl alias "cpuStartTiming" (byval timer as integer)
declare function cpuGetTiming cdecl alias "cpuGetTiming" () as u32
declare function cpuEndTiming cdecl alias "cpuEndTiming" () as u32

'TODO: put those back at inlined functions

#define timerTick(int_timer) ( TIMER_DATA(int_timer) )
#define timerUnpause(int_timer) TIMER_CR((int_timer)) or= TIMER_ENABLE
#define timerTicks2usec(u32_ticks) (((cast(u64,u32_ticks))*1000000)\BUS_CLOCK)
#define timerTicks2msec(u32_ticks) (((cast(u64,u32_ticks))*1000)\BUS_CLOCK)
#define timerFreqToTicks_1(int_freq) (-BUS_CLOCK \ (int_freq))
#define timerFreqToTicks_64(int_freq) ((-BUS_CLOCK shr 6) \ (int_freq))
#define timerFreqToTicks_256(int_freq) ((-BUS_CLOCK shr 8) \ (int_freq))
#define timerFreqToTicks_1024(int_freq) ((-BUS_CLOCK shr 10) \ (int_freq))


#endif
